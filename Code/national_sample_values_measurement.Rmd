---
title: "L&T PxV Measurement invariance"
author: "John Flournoy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    toc: true
---


```{r echo=F, results='hide', warning=F, message=F}
library(future)
nworkers1 <- 28/4
nworkers2 <- 4
nworkers <- 28
# nworkers <- availableCores() - 1
data_dir <- '/home/flournoy/otherhome/data/lnt_pxvx'
# data_dir <- '/data/jflournoy/lnt_pxvx/'

suppressMessages(library('tidyverse'))
lnt_df <- haven::read_sav(file.path(data_dir, 'LT_wideAGT1234.sav'))
lnt_df_nat <- dplyr::filter(lnt_df, aSubsample == 1)

create_scoring_frame <- function(items, rev_pattern = '.*x$', 
                                 sub_pattern = '^[abcd](.*?)x*$', 
                                 sub_replacement = '\\1',
                                 factor_name = NULL){
  scoring_vec <- -2*as.numeric(grepl(rev_pattern, items))+1
  new_items <- gsub(pattern = sub_pattern, replacement = sub_replacement, items)
  scoring_df <- data.frame(item = new_items, scoring = scoring_vec,
                           stringsAsFactors = FALSE)
  if(!is.null(factor_name)){
    scoring_df$factor_name <- factor_name
  }
  return(scoring_df)
}

#Some regex help munging the code from SPSS
# (\wbfi\d+x*)(?:\W+\+\W*)*
# '\1'
#
# compute (\w+) = 100\*\(mean(\(.*?\)) - 1\) */ *\d\. 
# \1 <- create_scoring_frame(\n  c\2\n  factor_name = '\1')
#
# val_cols <- c('aspfin',
#               'BFA_MT',
#               'HRZ_COL',
#               'HRZ_IND',
#               'MVI_POMP',
#               'USI',
#               'VRT_COL',
#               'VRT_IND')

lnt_scales_list <- list(
  bfi_s_scale = create_scoring_frame(
    c('abfi32', 'abfi7', 'abfi42', 'abfi33', 'abfi13', 'abfi51', 'abfi37x',
      'abfi8x', 'abfi2x', 'abfi12x', 'abfi47x', 'abfi49x'),
    factor_name = 'bfi_s_scale'),
  bfi_d_scale = create_scoring_frame(
    c('abfi26', 'abfi36', 'abfi16', 'abfi31x', 'abfi11', 'abfi5', 'abfi25', 'abfi20', 'abfi39x'),
    factor_name = 'bfi_d_scale'),
  bfi_hp8 = create_scoring_frame(
    c('abfi45x', 'abfi46x', 'abfi47x', 'abfi48x', 'abfi49x', 'abfi50', 'abfi51', 'abfi52'), 
    factor_name = 'bfi_hp8'),
  bfi_c = create_scoring_frame(
    c('abfi3', 'abfi8x', 'abfi13', 'abfi18x', 'abfi23x', 'abfi28', 'abfi33', 'abfi38', 'abfi43x'), 
    factor_name = 'bfi_c'),
  bfi_a = create_scoring_frame(
    c('abfi2x', 'abfi7', 'abfi12x', 'abfi17', 'abfi22', 'abfi27x', 'abfi32', 'abfi37x', 'abfi42'), 
    factor_name = 'bfi_a'),
  bfi_a6 = create_scoring_frame(
    c('abfi55', 'abfi56', 'abfi57', 'abfi58x', 'abfi59x', 'abfi60x', 'abfi61x', 'abfi62x'), 
    factor_name = 'bfi_a6'),
  bfi_e = create_scoring_frame(
    c('abfi1', 'abfi6x', 'abfi11', 'abfi16', 'abfi21x', 'abfi26', 'abfi31x', 'abfi36'), 
    factor_name = 'bfi_e'),
  bfi_n = create_scoring_frame(
    c('abfi4', 'abfi9x', 'abfi14', 'abfi19', 'abfi24x', 'abfi29', 'abfi34x', 'abfi39'), 
    factor_name = 'bfi_n'),
  bfi_o = create_scoring_frame(
    c('abfi5', 'abfi10', 'abfi15', 'abfi20', 'abfi25', 'abfi30', 'abfi35x', 'abfi40', 'abfi41x', 'abfi44'), 
    factor_name = 'bfi_o'),
  bfas_ac = create_scoring_frame(
    c('bbfas20x', 'bbfas21', 'bbfas22', 'bbfas23x', 'bbfas24', 
      'bbfas25x', 'bbfas26x', 'bbfas27', 'bbfas28x', 'bbfas29'),
    factor_name = 'bfas_ac'),
  bfas_ap = create_scoring_frame(
    c('bbfas30', 'bbfas31x', 'bbfas32', 'bbfas33x', 'bbfas34', 
      'bbfas35', 'bbfas36x', 'bbfas37x', 'bbfas38x', 'bbfas102x'),
    factor_name = 'bfas_ap'),
  bfas_ci = create_scoring_frame(
    c('bbfas40', 'bbfas41x', 'bbfas42x', 'bbfas43x', 'bbfas44', 
      'bbfas45x', 'bbfas46', 'bbfas47', 'bbfas48x', 'bbfas49x'),
    factor_name = 'bfas_ci'),
  bfas_co = create_scoring_frame(
    c('bbfas50x', 'bbfas51', 'bbfas52', 'bbfas53', 'bbfas54x', 
      'bbfas55', 'bbfas56x', 'bbfas57x', 'bbfas58', 'bbfas59'),
    factor_name = 'bfas_co'),
  bfas_ea = create_scoring_frame(
    c('bbfas70', 'bbfas71', 'bbfas72x', 'bbfas73', 'bbfas74x', 
      'bbfas75', 'bbfas76', 'bbfas77x', 'bbfas78', 'bbfas79x'),
    factor_name = 'bfas_ea'),
  bfas_ee = create_scoring_frame(
    c('bbfas60', 'bbfas61x', 'bbfas62x', 'bbfas63x', 'bbfas64', 
      'bbfas65x', 'bbfas66x', 'bbfas67', 'bbfas68', 'bbfas69'),
    factor_name = 'bfas_ee'),
  bfas_nv9 = create_scoring_frame(
    c('bbfas1x', 'bbfas2', 'bbfas3x', 'bbfas4', 'bbfas5x', 
      'bbfas6', 'bbfas7x', 'bbfas8', 'bbfas9'),
    factor_name = 'bfas_nv9'),
  bfas_nv = create_scoring_frame(
    c('bbfi58', 'bbfas1x', 'bbfas2', 'bbfas3x', 'bbfas4', 
      'bbfas5x', 'bbfas6', 'bbfas7x', 'bbfas8', 'bbfas9'),
    factor_name = 'bfas_nv'),
  bfas_nw = create_scoring_frame(
    c('bbfas10x', 'bbfas11', 'bbfas12x', 'bbfas13', 'bbfas14x', 
      'bbfas15', 'bbfas16', 'bbfas17x', 'bbfas18', 'bbfas19'),
    factor_name = 'bfas_nw'),
  bfas_oi = create_scoring_frame(
    c('bbfas80', 'bbfas81x', 'bbfas82', 'bbfas83', 'bbfas84x', 
      'bbfas85x', 'bbfas86', 'bbfas87', 'bbfas88x', 'bbfas89'),
    factor_name = 'bfas_oi'),
  bfas_oo = create_scoring_frame(
    c('bbfas90', 'bbfas91', 'bbfas92', 'bbfas93', 'bbfas94x', 
      'bbfas95', 'bbfas96', 'bbfas97x', 'bbfas98x', 'bbfas99x'),
    factor_name = 'bfas_oo'),
  aspfin = create_scoring_frame(
    c('basp12', 'basp13', 'basp14', 'basp15', 'basp16'),
    factor_name = 'aspfin'),
  bfa_mt = create_scoring_frame(
    c('abfas105', 'abfas106', 'abfas107x', 'abfas108x', 'abfas109', 'abfas110', 'abfas111x', 
      'abfas112x', 'abfas113', 'abfas114', 'abfas115', 'abfas116x', 'abfas117x', 'abfas118x'),
    factor_name = 'bfa_mt'),
  hrz_ind = create_scoring_frame(
    c('aind1', 'aind2', 'aind3', 'aind4'),
    factor_name = 'hrz_ind'),
  hrz_col = create_scoring_frame(
    c('aind9', 'aind10', 'aind11', 'aind12'),
    factor_name = 'hrz_col'),
  mvi = create_scoring_frame(
    c('aval7', 'aval9', 'aval11', 'aval13', 'aval15', 'aval17', 'aval18', 'aval20', 'aval21', 
      'aval23', 'aval8x', 'aval10x', 'aval12x', 'aval14x', 'aval16x', 'aval19x', 'aval22x'),
    factor_name = 'mvi'),
  usi = create_scoring_frame(
    c('ausi1', 'ausi2x', 'ausi3x', 'ausi5', 'ausi6x', 'ausi7'),
    factor_name = 'usi'),
  vrt_ind = create_scoring_frame(
    c('aind5', 'aind6', 'aind7', 'aind8'),
    factor_name = 'vrt_ind'),
  vrt_col = create_scoring_frame(
    c('aind13', 'aind14', 'aind15', 'aind16'),
    factor_name = 'vrt_col'))

lnt_scales_df <- do.call(dplyr::bind_rows, lnt_scales_list)


pVarNames <- c(bfi_s_scale="Social Self-Regulation",
               bfi_c=".Conscientiousness",
               bfas_ci="..Industriousness",
               bfas_co="..Orderliness",
               bfi_hp8=".Honesty/Propriety",
               bfi_a=".Agreeableness",
               bfi_a6=".Agreeableness-Six",
               bfas_ac="..Compassion",
               bfas_ap="..Politeness",
               bfi_n=".Neuroticism",
               bfas_nv9 = ".Neuroticism-Nine",
               bfas_nv="..Volatility",
               bfas_nw="..Withdrawal",
               bfi_d_scale="Dynamism",
               bfi_e=".Extraversion",
               bfas_ea="..Assertiveness",
               bfas_ee="..Enthusiasm",
               bfi_o=".Openness",
               bfas_oi="..Intellect",
               bfas_oo="..Openness")

vVarNames <- c('aspfin'='Financial Aspirations',
               'bfa_mt'='Materialism',
               'hrz_col'='Horizontal Collectivism',
               'hrz_ind'='Horizontal Individualism',
               'mvi'='Mature Values Index',
               'usi'='Unmitigated Self-Interest',
               'vrt_col'='Vertical Collectivism',
               'vrt_ind'='Vertical Individualism')
```

# Creating factor-item mapping

As part of this process, outputting the alpha coefficients.

```{r echo=F, warning=F, message=F}
item_regexs <- paste0('^[abcd](',
                      paste(unique(lnt_scales_df$item), 
                            collapse = '|'),
                      ')$')

lnt_items_nat <- dplyr::select(lnt_df_nat, matches(item_regexs))

create_wave_keys <- function(scoring_df, wave_prefix = 'a'){
  scoring_df_w <- tidyr::spread(scoring_df, factor_name, scoring, fill = 0)
  rownames(scoring_df_w) <- paste0(wave_prefix, scoring_df_w$item)
  scoring_df_w <- scoring_df_w[,-1]
  wave_keys <- psych::keys2list(scoring_df_w)
  return(wave_keys)
}

wave1_keys <- create_wave_keys(lnt_scales_df, 'a')
wave1_scored <- psych::scoreItems(keys = wave1_keys, lnt_items_nat)
wave2_keys <- create_wave_keys(lnt_scales_df, 'b')
wave2_scored <- psych::scoreItems(keys = wave2_keys, lnt_items_nat)
wave3_keys <- create_wave_keys(lnt_scales_df, 'c')
wave3_scored <- psych::scoreItems(keys = wave3_keys, lnt_items_nat)
wave4_keys <- create_wave_keys(lnt_scales_df, 'd')
wave4_scored <- psych::scoreItems(keys = wave4_keys, lnt_items_nat)

cat('**Wave 1**\n\n')
wave1_scored$alpha
cat('**Wave 2**\n\n')
wave2_scored$alpha
cat('**Wave 3**\n\n')
wave3_scored$alpha
cat('**Wave 4**\n\n')
wave4_scored$alpha
```

# Generate lavaan syntax

```{r echo=F, results='hide', warning=F, message=F}
library(lavaan)
library(semTools)
check_manifests_exist <- function(manifest_vec, aDF){
  df_names <- names(aDF)
  wave_manifest_names <- unlist(lapply(c('a', 'b', 'c', 'd'), paste0, manifest_vec))
  all_in_df_names <- all(wave_manifest_names %in% df_names)
  return(all_in_df_names)
}

create_lav_id_strat_widaman <- function(factor_name){
  factor_name_w1 <- paste0(factor_name, '_W1')
  factor_intercept <- paste0(factor_name_w1, ' ~ 0*1')
  factor_var <- paste0(factor_name_w1, ' ~~ 1*', factor_name_w1)
  paste0(factor_intercept, '\n', factor_var)
}

create_lav_growth_model <- function(factor_name, manifest_vec, int.i.group_equal = F, var.i.group_equal = F, int.s.group_equal = F, var.s.group_equal = F, cov.group_equal = F, num_groups = 4, center_wave = 1){
  wave_factors <- paste0(factor_name, '_W', 1:4)
  iname <- paste0(factor_name, '_i')
  intercept <- paste0(iname, ' =~ ', 
                      paste(
                        paste0('1*', wave_factors),
                        collapse = ' + '))
  sname <- paste0(factor_name, '_s')
  slope <- paste0(sname, ' =~ ', 
                      paste(
                        paste0(1:4 - center_wave, '*', wave_factors),
                        collapse = ' + '))
  factor_intercepts <- paste(paste0(wave_factors, ' ~ 0*1'), collapse = '\n')
  factor_variances <- paste(
    paste0(wave_factors, 
           paste0('~~ c(', rep('fctrvar', num_groups), ')*'), 
                  wave_factors),
    collapse = '\n')
  growth_code <- paste(intercept, slope, factor_intercepts, factor_variances, sep = '\n')
  if(int.i.group_equal){
    int.i <- paste0(iname, ' ~ c(', paste(rep('inti', num_groups), collapse = ', '), ')*1')
    growth_code <- paste(growth_code, int.i, sep = '\n')
  }
  if(int.s.group_equal){
    int.s <- paste0(sname, ' ~ c(', paste(rep('ints', num_groups), collapse = ', '), ')*1')
    growth_code <- paste(growth_code, int.s, sep = '\n')
  }
  if(var.i.group_equal){
    var.i <- paste0(iname, ' ~~ c(', paste(rep('vari', num_groups), collapse = ', '), ')*', iname)
    growth_code <- paste(growth_code, var.i, sep = '\n')
  }
  if(var.s.group_equal){
    var.s <- paste0(sname, ' ~~ c(', paste(rep('vars', num_groups), collapse = ', '), ')*', sname)
    growth_code <- paste(growth_code, var.s, sep = '\n')
  }
  if(cov.group_equal){
    covar.is <- paste0(sname, ' ~~ c(', paste(rep('covar_is', num_groups), collapse = ', '), ')*', iname)
    growth_code <- paste(growth_code, covar.is, sep = '\n')
  }
  return(growth_code)
}

create_lav_factor_loadings <- function(factor_name, manifest_vec, group_equal = F, long_free = F, num_groups = 4){
  if(long_free && group_equal){
    stop("Can't set groups equal and free longitudinal constraints.")
  }
  wave_factors <- paste0(factor_name, '_W', 1:4)
  num_indicators <- length(manifest_vec)
  load_labels <- lapply(paste0('L', 1:num_indicators),
                        function(label){
                          rep_labs <- rep(label, num_groups)
                          if(!group_equal){
                            rep_labs <- paste0(rep_labs, letters[1:num_groups])
                          }
                          paste0('c(', paste(rep_labs, collapse = ', '), ')')
                        })
  loadings <- c(paste0(load_labels, '*'))
  wave_manifests_rhs <- lapply(letters[1:4],
                           function(letter){
                             if(long_free) {
                               paste(paste0(c(loadings[[1]], rep('', length(loadings)-1)),
                                            letter, 
                                            manifest_vec),
                                     collapse = ' + ')  
                             } else {
                               paste(paste0(loadings,
                                            letter, 
                                            manifest_vec),
                                     collapse = ' + ')  
                             }
                           })
  wave_eqs <- paste0(wave_factors, ' =~ ', wave_manifests_rhs)
  all_wave_model <- paste(wave_eqs, collapse = '\n')
  return(all_wave_model)
}

create_lav_ints <- function(manifest_vec, group_equal = F, long_free = F, num_groups = 4, 
                            fix_first_intercept = F){
  if(long_free && group_equal){
    stop("Can't set groups equal and free longitudinal constraints.")
  }
  int_grp_eqs <- lapply(manifest_vec, function(man_var){
    int_label <- paste0('int_', which(manifest_vec == man_var))
    grp_labels <- rep(int_label, num_groups)
    if(!group_equal){
      grp_labels <- paste0(grp_labels, 'g', 1:num_groups)
    }
    grp_labels_collapsed <- paste(grp_labels, collapse = ', ')
    eq_rhs <- paste0('c(', grp_labels_collapsed, ')*1')
    eq_lhs <- paste0(letters[1:4], man_var)
    if(long_free && which(manifest_vec == man_var) > 1){
      eq <- paste0(eq_lhs, ' ~ ', '1')  
    } else if(fix_first_intercept && which(manifest_vec == man_var) == 1){
      eq <- paste0(eq_lhs, ' ~ ', '0*1')  
    } else {
      eq <- paste0(eq_lhs, ' ~ ', eq_rhs)
    }
    paste(eq, collapse = '\n')
  })
  int_all_eqs <- paste(int_grp_eqs, collapse = '\n\n')
  return(int_all_eqs)
}

create_lav_resid_var <- function(manifest_vec, group_equal = F, long_free = F, num_groups = 4){
  if(long_free && group_equal){
    stop("Can't set groups equal and free longitudinal constraints.")
  }
  var_grp_eqs <- lapply(manifest_vec, function(man_var){
    var_label <- paste0('v_', which(manifest_vec == man_var))
    grp_labels <- rep(var_label, num_groups)
    if(!group_equal){
      grp_labels <- paste0(grp_labels, 'g', 1:num_groups)
    }
    grp_labels_collapsed <- paste(grp_labels, collapse = ', ')
    eq_rhs <- paste0('c(', grp_labels_collapsed, ')')
    eq_lhs <- paste0(letters[1:4], man_var)
    if(long_free){
      eq <- paste0(eq_lhs, ' ~~ ', eq_lhs)
    } else {
      eq <- paste0(eq_lhs, ' ~~ ', eq_rhs, '*', eq_lhs)
    }
    paste(eq, collapse = '\n')
  })
  var_all_eqs <- paste(var_grp_eqs, collapse = '\n\n')
  return(var_all_eqs)
}

create_lav_resid_covar <- function(manifest_vec, group_equal = F, long_free = F, num_groups = 4){
  if(long_free && group_equal){
    stop("Can't set groups equal and free longitudinal constraints.")
  }
  covar_grp_eqs <- lapply(manifest_vec, function(man_var){
    lag_distances <- unlist(lapply(3:1, function(x) seq(from = 1, to = x, by = 1)))
    var_label <- paste0('cv_', which(manifest_vec == man_var), lag_distances)
    grp_labels_collapsed <- lapply(var_label, function(alab){
      thelabs <- rep(alab, num_groups)
      if(!group_equal){
        thelabs <- paste0(thelabs, 'g', 1:num_groups)
      }
      thelabs_collapsed <- paste(thelabs, collapse = ', ')
      return(thelabs_collapsed)
    })
    if(long_free){
      connectors <- ' ~~ '
    } else {
      connectors <- paste0(' ~~ c(', grp_labels_collapsed, ')*')
    }
    wave_vars <- paste0(letters[1:4], man_var)
    covar_label_matrix <- combn(wave_vars, 2)
    eqs <- paste0(covar_label_matrix[1,], connectors, covar_label_matrix[2,])
    eqs_collapsed <- paste(eqs, collapse = '\n')
    return(eqs_collapsed)
  })
  covar_grp_eqs_all <- paste(covar_grp_eqs, collapse = '\n\n')
  return(covar_grp_eqs_all)
}

create_lav_invariance_model <- function(factor_name, manifest_vec, type = c('unconstrained', 'long_metric', 'long_strong', 'long_strict', 'baseline','metric','strong', 'strict'), num_groups = 4, no_widman = F, fix_first_intercept = F){
  #unconstrained: estimate first loading, constrain across waves, but freely
  #estimate remaining loadings. Estimate first intercept but constrain to be
  #invariant across time. Freely estimate remaining parameters. Allow covariance
  #among residuals of same item across waves.
  #
  #long_metric: constrain loadings to be the same across time (but vary across
  #group).
  #
  #long_strong: constain intercepts to be the same across time (but vary across
  #group).
  #
  #long_scrict: constain residuals to be the same across time within item (but
  #vary across group).
  #
  #baseline: strict longitudinal invariance with added constraint that 
  #covariance of residuals across the same lag distance should be the same.
  #
  #metric: factor loadings equal across groups.
  #
  #strong: intercepts equal across groups.
  #
  #strict: residual variances are equal across groups.
  
  amod <- switch(type,
                 unconstrained = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 long_metric = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'), 
                 long_strong = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 long_strict = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, 
                       group_equal = F, long_free = T, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 baseline = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, 
                       group_equal = F, long_free = F, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 metric = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, group_equal = T, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, group_equal = F, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, group_equal = F, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, group_equal = F, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 strong = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, group_equal = T, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, group_equal = T, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, group_equal = F, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, group_equal = F, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'),
                 strict = paste(
                   c(create_lav_factor_loadings(
                       factor_name, manifest_vec, group_equal = T, num_groups = num_groups),
                     create_lav_ints(
                       manifest_vec, group_equal = T, num_groups = num_groups,
                       fix_first_intercept = fix_first_intercept),
                     create_lav_resid_var(
                       manifest_vec, group_equal = T, num_groups = num_groups),
                     create_lav_resid_covar(
                       manifest_vec, group_equal = F, num_groups = num_groups)), 
                   collapse = '\n\n#---\n\n'))
  if(no_widman){
    return(amod)
  } else {
    amod <- paste(create_lav_id_strat_widaman(factor_name = factor_name), amod, sep = '\n')
    return(amod) 
  }
}

get_factor_items <- function(scoring_df, factor_name){
  scoring_df$item[scoring_df$factor_name == factor_name]
}

get_item_colnames <- function(manifest_vec){
  item_colnames <- unlist(lapply(letters[1:4], paste0, manifest_vec))
}

sem_invar <- function(model, data, ...){
  fit <- lavaan(model = model, data = data,
                int.lv.free = T,
                auto.fix.first = F,
                int.ov.free = TRUE, 
                auto.var = TRUE, 
                auto.cov.lv.x = TRUE,
                auto.cov.y = TRUE,
                ...)
  return(fit)
} 

growth_cofs <- function(model, data, ...){
  fit <- lavaan::lavaan(model = model, data = data,
                        meanstructure = TRUE, 
                        int.ov.free = TRUE, 
                        int.lv.free = TRUE, 
                        auto.fix.first = TRUE, 
                        auto.fix.single = TRUE, 
                        auto.var = TRUE, 
                        auto.cov.lv.x = TRUE, 
                        auto.th = TRUE, 
                        auto.delta = TRUE, 
                        auto.cov.y = TRUE, ...)
  return(fit)
}

run_invariance_model <- function(factor_name, manifest_vec, item_data, type = 'baseline', group = NULL, num_groups = 4, ...){
  an_invar_model <- create_lav_invariance_model(
    factor_name, 
    manifest_vec, 
    type = type, 
    num_groups = num_groups)
  
  if(is.null(group)){
    a_fit <- sem_invar(model = an_invar_model, 
                     data = item_data,
                     ...)    
  } else {
    a_fit <- sem_invar(model = an_invar_model, 
                     data = item_data,
                     group = group, 
                     ...)
  }
  return(a_fit)
}

run_invariance_tests <- function(factor_name, manifest_vec, item_data, fit_measures, group, return_models = F, ...){
  require(future)
  require(lavaan)
  require(tibble)
  require(tidyr)
  require(dplyr)
  require(listenv)
  all_invar_types <- c('unconstrained', 'long_metric', 'long_strong', 'long_strict', 'baseline','metric','strong', 'strict')
  
  invar_models_future_listenv <- listenv::listenv()
  for(it in seq_along(all_invar_types)){
    invar_models_future_listenv[[it]] <- future::future({
      message(paste0("Running: ", factor_name, ", ", all_invar_types[[it]]))
      try(run_invariance_model(factor_name, 
                           manifest_vec, 
                           item_data, 
                           type = all_invar_types[[it]], 
                           group = group, 
                           ...))
    })
  }
  
  invar_models_list <- lapply(as.list(invar_models_future_listenv), future::value) 
  
  fit_statistics <- future.apply::future_lapply(
    invar_models_list,
    function(x){
      tryfitmeasure <- try(fitmeasures(x, fit.measures = fit_measures))
      if(class(tryfitmeasure) == 'try-error'){
        rez <- rep(NA, length(fit_measures))
        names(rez) <- fit_measures
        return(rez)
      } else {
        return(tryfitmeasure)
      }
    }
  )
  fit_statistics_len <- lapply(fit_statistics, length)
  fit_stat_df <- data_frame(
    factor_name = factor_name,
    invar_type = rep(all_invar_types, fit_statistics_len),
    fit_stat = names(unlist(fit_statistics)),
    value = unlist(fit_statistics))
  
  lrt_test <- do.call(
    function(...){ 
      try(lavTestLRT(..., model.names = all_invar_types))
    }, 
    invar_models_list)
  if(class(lrt_test) == 'try-error' || class(lrt_test) != 'anova'){
    lrt_test_df <- data.frame()
  } else {
    lrt_test_df <- tibble::as_data_frame(lrt_test)
    lrt_test_df$invar_type <- rownames(lrt_test)
    lrt_test_df <- tidyr::gather(lrt_test_df, fit_stat, value,
                                 -invar_type)
    lrt_test_df$factor_name <- factor_name 
  }
  
  summary_df <- dplyr::bind_rows(fit_stat_df, lrt_test_df)
  
  names(invar_models_list) <- all_invar_types
  if(return_models){
    return(list(fit_tests = summary_df, models = invar_models_list))
  } else {
    return(summary_df)
  }
}

test_factors_for_invariance <- function(factor_names, indicators_df, item_data, fit_measures = c('mfi', 'cfi', 'rmsea', 'rmsea.ci.lower', 'rmsea.ci.upper'), group, ...){
  require(future)
  invar_mod_listenv <- listenv::listenv()
  for(fn in seq_along(factor_names)){
    factor_name <- factor_names[[fn]]
    factor_items <- get_factor_items(indicators_df, factor_name)
    if(!check_manifests_exist(factor_items, item_data)) {
      stop(factor_name, ' does not have item columns in item_data')
    }
    this_factor_data <- item_data[, c(get_item_colnames(factor_items), group)]
    invar_mod_listenv[[fn]] <- future::future(
      {
        message(paste0("Running: ", factor_name))
        run_invariance_tests(factor_name = factor_name, 
                             manifest_vec = factor_items, 
                             item_data = this_factor_data, 
                             fit_measures = fit_measures, 
                             group = group,
                             ...)
      })
  }
  return(as.list(invar_mod_listenv))
}
```

This is an example of the measurement model diagram, using Horizontal Collectivism, for one group demonstrating constraints for the strict measurement invariance model. Paths with the same label are constrained to have the same path weight, and in the strict invariance model, all labeled path weights must be the same for each decade group. The residual covariances are an exception: the constraint imposed is that residual covariance is the same across the same time-lag, for the same indicator (so e.g., `cov(aind9, bind9) = cov(bind9, cind9)`, and `cov(aind9, cind9) = cov(bind9, dind9)`), but these are not constrained to be the same across group. Since this constraint is imposed in every factorial invariance model tested, it does not affect the fit comparisons.

```{r fig.width = 7.5, fig.height = 10, echo = F, warning = F, error = F}
lnt_df_nat_decades <- dplyr::filter(lnt_df_nat, aage < 60, aage >= 20) 
lnt_df_nat_decades$decade_group <- factor(lnt_df_nat_decades$aage %/% 10, levels = c(2, 3, 4, 5), labels = c('20s', '30s', '40s', '50s'))
lnt_df_nat_decades$agender <- haven::as_factor(lnt_df_nat_decades$agender)
lnt_nat_decades_items <- dplyr::select(lnt_df_nat_decades, matches(item_regexs), decade_group, agender)

demo_model <- create_lav_invariance_model('hrz_col', 
                                          get_factor_items('hrz_col', scoring_df = lnt_scales_df), 
                                          type = 'strict')

demo_model_fit <- sem_invar(demo_model, data = lnt_nat_decades_items, group = 'decade_group', do.fit = F)
cat(demo_model)
```

```{r eval = F}
library(semPlot)
semPaths(demo_model_fit, ask = F, include = 1, node.width = .75, layout = 'tree2', rotation = 2, curvature = 9,
         intStyle = 'multi', levels = c(1,5,6,7), edge.color = '#bbbbbb', edge.label.color = '#444444',
         nCharEdges = 5, edge.label.cex = .5, nCharNodes = 8)
```


```{r echo=F, results='hide', warning=F, message=F}
plan(tweak(multiprocess, gc = T, workers = nworkers))

factor_names <- names(vVarNames)
fit_measures <- c('mfi', 'cfi', 'rmsea', 'rmsea.ci.lower', 'rmsea.ci.upper')

invar_test_rez_fn <- '../Rez/invariance_measures_long.Rds'
if(!file.exists(invar_test_rez_fn)){
  invar_tests_and_models <- test_factors_for_invariance(
    factor_names = factor_names, 
    indicators_df = lnt_scales_df, 
    item_data = lnt_nat_decades_items, 
    fit_measures = fit_measures, 
    group = 'decade_group',  
    missing = 'fiml')
  invar_tests_and_models_df <- dplyr::bind_rows(lapply(invar_tests_and_models, future::value))
  saveRDS(invar_tests_and_models_df, invar_test_rez_fn)
} else {
  invar_tests_and_models_df <- readRDS(invar_test_rez_fn)
}
```

# Results

## MFI, CFI & *IC

To determine the invariance of measurement over groups, we can examine the $\chi^2$ test. But this is often an overly strict test with a large sample size. Relative change in AIC and BIC (with lower values, and negative changes, being better) help guide interpretation by incorporating information about the number of parameters (AIC, BIC) and sample size (BIC). Cheung & Rensvold (2002) recomend using $\Delta\text{CFI}$ because it is not influenced by complexity or sample size, and does not correlate with overall fit measures. In this paper, they write, "A value of $\Delta\text{CFI}$ smaller than or equal to –0.01 indicates that the null hypothesis of invariance should not be rejected" (p 251). Below, I generally ignore the $\chi^2$ tests in interpretation but present them for completeness.

```{r results='asis', echo=F, warning=F, message=F}
#  [1] "bfi_s_scale" "bfi_d_scale" "bfi_hp8"     "bfi_c"       "bfi_a"       "bfi_a6"     
#  [7] "bfi_e"       "bfi_n"       "bfi_o"       "bfas_ac"     "bfas_ap"     "bfas_ci"    
# [13] "bfas_co"     "bfas_ea"     "bfas_ee"     "bfas_nv9"    "bfas_nv"     "bfas_nw"    
# [19] "bfas_oi"     "bfas_oo"     "aspfin"      "bfa_mt"      "hrz_ind"     "hrz_col"    
# [25] "mvi"         "usi"         "vrt_ind"     "vrt_col"  

invar_tests_and_models_df <- dplyr::mutate(
  invar_tests_and_models_df, 
  invar_type = factor(invar_type,
                      levels = c('baseline','metric','strong', 'strict'),
                      labels = c('baseline','metric','strong', 'strict')))

invar_tests_and_models_df_w <- mutate_at(
  tidyr::spread(
    invar_tests_and_models_df,
    fit_stat,
    value),
  vars(AIC:rmsea.ci.upper),
  as.numeric)
invar_tests_and_models_df_w <- arrange(
  invar_tests_and_models_df_w,
  factor_name, invar_type)
invar_tests_and_models_df_w <- mutate_at(
  group_by(invar_tests_and_models_df_w, factor_name),
  vars(dAIC = AIC, dBIC = BIC, dCFI = cfi, dMFI = mfi),
  function(x) x - lag(x))
invar_tests_and_models_df_w <- mutate_at(
  group_by(invar_tests_and_models_df_w, factor_name),
  vars(d2AIC = AIC, d2BIC = BIC, d2CFI = cfi, d2MFI = mfi),
  function(x) x - lag(x, n = 3))
invar_tests_and_models_df_w <- dplyr::mutate(
  ungroup(invar_tests_and_models_df_w),
  dAIC = sprintf('%.1f', dAIC),
  dBIC = sprintf('%.1f', dBIC),
  d2AIC = sprintf('%.1f', d2AIC),
  d2BIC = sprintf('%.1f', d2BIC),
  `P dChisq` = ifelse(`Pr(>Chisq)` < 1e-3, 
                        '<.001',
                        sprintf('%.3f', `Pr(>Chisq)`)),
  dChisq = sprintf('%.1f',`Chisq diff`),
  dDf = `Df diff`,
  cfi = sprintf('%.3f', cfi),
  dCFI = sprintf('%.3f', dCFI),
  d2CFI = sprintf('%.3f', d2CFI),
  dMFI = sprintf('%.3f', dMFI),
  d2MFI = sprintf('%.3f', d2MFI),
  rmsea = sprintf('%.3f', rmsea),
  rmsea.ci.lower = sprintf('%.3f', rmsea.ci.lower),
  rmsea.ci.upper = sprintf('%.3f', rmsea.ci.upper),
  rmsea = paste0(rmsea, ' [', rmsea.ci.lower, ', ', rmsea.ci.upper,']'),
  factor_name = factor(factor_name, 
                       levels = names(c(vVarNames, pVarNames)),
                       labels = c(vVarNames, pVarNames)))
invar_tests_and_models_df_w <- mutate(
  arrange(invar_tests_and_models_df_w,
          factor_name, invar_type),
  factor_name_c = as.character(factor_name),
  invar_type_c = as.character(invar_type)
)
invar_tests_and_models_df_w <- mutate_all(
  invar_tests_and_models_df_w,
  function(x) ifelse(is.na(x) | x == 'NA', '', x)
)
invar_tests_and_models_df_w <- dplyr::select(
  invar_tests_and_models_df_w,
  factor_name, invar_type, factor_name_c, invar_type_c, 
  dAIC, d2AIC, dBIC, d2BIC, dChisq, Df, dDf, `P dChisq`,
  cfi, dCFI, d2CFI, dMFI, d2MFI, rmsea)

column_labels <- c(
  invar_type_c = 'Type', 
  dAIC = '$\\Delta\\text{AIC}$', 
  d2AIC = '$\\Delta_{1,4}\\text{AIC}$', 
  dBIC = '$\\Delta\\text{BIC}$', 
  d2BIC = '$\\Delta_{1,4}\\text{BIC}$', 
  dChisq = '$\\Delta\\chi^2$', #6
  Df = '$\\text{Df}$', #7
  dDf = '$\\Delta\\text{Df}$', #8
  `P dChisq` = '$P(>\\Delta\\chi^2)$', #9
  cfi = '$\\text{CFI}$', 
  dCFI = '$\\Delta\\text{CFI}$', 
  d2CFI = '$\\Delta_{1,4}\\text{CFI}$', 
  dMFI = '$\\Delta\\text{MFI}$', 
  d2MFI = '$\\Delta_{1,4}\\text{MFI}$', 
  rmsea = '$\\text{RMSEA}$')

conclusions_list <- as.list(rep('', length(c(vVarNames, pVarNames))))
names(conclusions_list) <- c(vVarNames, pVarNames)

conclusions_list[['Financial Aspirations']] <- 'Invariant.'
conclusions_list[['Materialism']] <- 'Invariant.'
conclusions_list[['Horizontal Collectivism']] <- 'Problematic: Neither CFI nor AIC support strict invariance. Constraints from metric to strong invariance (intercepts) may be an issue.'
conclusions_list[['Horizontal Individualism']] <- 'Invariant.'
conclusions_list[['Mature Values Index']] <- 'Likely invariant: Change in CFI and BIC suggest invariance, though AIC does not favor constraints beyond metric invariance.'
conclusions_list[['Unmitigated Self-Interest']] <- 'Possibly invariant: At each step, change in CFI suggests invariance, but baseline to strict change is greater than the recommended cutoff. Change in BIC suggests invariance, though AIC does not favor constraints beyond metric invariance.'
conclusions_list[['Vertical Collectivism']] <- 'Possibly invariant: At each step, change in CFI suggests invariance, but baseline to strict change is greater than the recommended cutoff. Change in BIC suggests invariance, though AIC does not favor constraints except from strong to strict.'
conclusions_list[['Vertical Individualism']] <- 'Possibly problematic: change in CFI rejects invariance between metric and strong, and between baseline and strict, which agrees with change in AIC. Change in BIC suggests invariance.'
conclusions_list[['Social Self-Regulation']] <- 'Invariant.'
conclusions_list[['.Conscientiousness']] <- 'Invariant, with the caveat that AIC favors only the metric constraints.'
conclusions_list[['..Industriousness']] <- 'Invariant.'
conclusions_list[['..Orderliness']] <- 'Invariant.'
conclusions_list[['.Honesty/Propriety']] <- 'Invariant.'
conclusions_list[['.Agreeableness']] <- 'Invariant.'
conclusions_list[['.Agreeableness-Six']] <- 'Invariant'
conclusions_list[['..Compassion']] <- 'Possibly invariant: At each step, change in CFI suggests invariance, but baseline to strict change is greater than the recommended cutoff. Change in BIC suggests invariance. AIC suggests constrained models fit worse, or at least no better, at each step.'
conclusions_list[['..Politeness']] <- 'Possibly invariant: At each step, change in CFI suggests invariance, but baseline to strict change is greater than the recommended cutoff. Change in BIC suggests invariance. AIC suggests constrained models fit worse, at each step except when adding metric constraints.'
conclusions_list[['.Neuroticism']] <- 'Invariant'
conclusions_list[['.Neuroticism-Nine']] <- 'Lilely Invariant.'
conclusions_list[['..Volatility']] <- 'Likely invariant: Change in CFI and BIC suggest invariance, though AIC does not favor constraints from metric to strong, or baseline to strict invariance.'
conclusions_list[['..Withdrawal']] <- 'Likely invariant (AIC rejects metric to strong, and baseline to strict).'
conclusions_list[['Dynamism']] <- 'Invariant (but see AIC).'
conclusions_list[['.Extraversion']] <- 'Invariant.'
conclusions_list[['..Assertiveness']] <- 'Invariant.'
conclusions_list[['..Enthusiasm']] <- 'Likely invariant: Change in CFI and BIC suggest invariance, though AIC does not favor constraints except from baseline to metric.'
conclusions_list[['.Openness']] <- 'Invariant (but see AIC).'
conclusions_list[['..Intellect']] <- 'Likely invariant: Change in CFI and BIC suggest invariance, though AIC does not favor constraints except from strong to strict, or baseline to strict.'
conclusions_list[['..Openness']] <- 'Invariant (but see AIC).'
```

```{r buildtables}
nothingburger <- do(group_by(invar_tests_and_models_df_w, factor_name),{
  table_df <- select(., -factor_name, -invar_type, -factor_name_c)
  title <- unique(.$factor_name_c)
  names(table_df) <- column_labels
  comm <- paste0('\\hline \n ',
                 paste(paste0('\\multicolumn{12}{l}{', 
                       strwrap(conclusions_list[[title]], width = 90), '} \\\\'), 
                       collapse = '\n'), '\n')
  print(xtable::xtable(table_df[, -c(6,9)], caption = title, align = c('r','l',rep('r', 12))), 
        include.rownames = T, sanitize.colnames.function = identity, comment = FALSE,
        caption.placement = 'top', table.placement="!htp",
        hline.after=c(-1, 0),
        add.to.row = list(pos = list(4),
                          command = comm))
  data.frame()
})

```

\clearpage

## $\Delta\chi^2$ Tests

Below, just the $\Delta\chi^2$ tests.


```{r  results='asis', echo=F, warning=F, message=F}
nothingburger <- do(group_by(invar_tests_and_models_df_w, factor_name),{
  table_df <- select(., -factor_name, -invar_type, -factor_name_c)
  title <- unique(.$factor_name_c)
  names(table_df) <- column_labels
  print(xtable::xtable(table_df[, c(1,6:9)], caption = title, align = c('r','l',rep('r', length(6:9)))), 
        include.rownames = T, sanitize.colnames.function = identity, comment = FALSE,
        caption.placement = 'top', table.placement="!htp")
  data.frame()
})

```